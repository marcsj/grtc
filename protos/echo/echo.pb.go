// Code generated by protoc-gen-go. DO NOT EDIT.
// source: echo/echo.proto

package grpc_gateway_testing

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Empty struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}
func (*Empty) Descriptor() ([]byte, []int) {
	return fileDescriptor_echo_3348184e55b97ceb, []int{0}
}
func (m *Empty) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Empty.Unmarshal(m, b)
}
func (m *Empty) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Empty.Marshal(b, m, deterministic)
}
func (dst *Empty) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Empty.Merge(dst, src)
}
func (m *Empty) XXX_Size() int {
	return xxx_messageInfo_Empty.Size(m)
}
func (m *Empty) XXX_DiscardUnknown() {
	xxx_messageInfo_Empty.DiscardUnknown(m)
}

var xxx_messageInfo_Empty proto.InternalMessageInfo

type EchoRequest struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EchoRequest) Reset()         { *m = EchoRequest{} }
func (m *EchoRequest) String() string { return proto.CompactTextString(m) }
func (*EchoRequest) ProtoMessage()    {}
func (*EchoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_echo_3348184e55b97ceb, []int{1}
}
func (m *EchoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EchoRequest.Unmarshal(m, b)
}
func (m *EchoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EchoRequest.Marshal(b, m, deterministic)
}
func (dst *EchoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoRequest.Merge(dst, src)
}
func (m *EchoRequest) XXX_Size() int {
	return xxx_messageInfo_EchoRequest.Size(m)
}
func (m *EchoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EchoRequest proto.InternalMessageInfo

func (m *EchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

type EchoResponse struct {
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	MessageCount         int32    `protobuf:"varint,2,opt,name=message_count,json=messageCount,proto3" json:"message_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EchoResponse) Reset()         { *m = EchoResponse{} }
func (m *EchoResponse) String() string { return proto.CompactTextString(m) }
func (*EchoResponse) ProtoMessage()    {}
func (*EchoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_echo_3348184e55b97ceb, []int{2}
}
func (m *EchoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EchoResponse.Unmarshal(m, b)
}
func (m *EchoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EchoResponse.Marshal(b, m, deterministic)
}
func (dst *EchoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EchoResponse.Merge(dst, src)
}
func (m *EchoResponse) XXX_Size() int {
	return xxx_messageInfo_EchoResponse.Size(m)
}
func (m *EchoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_EchoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_EchoResponse proto.InternalMessageInfo

func (m *EchoResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *EchoResponse) GetMessageCount() int32 {
	if m != nil {
		return m.MessageCount
	}
	return 0
}

// Request type for server side streaming echo.
type ServerStreamingEchoRequest struct {
	// Message string for server streaming request.
	Message string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	// The total number of messages to be generated before the server
	// closes the stream; default is 10.
	MessageCount int32 `protobuf:"varint,2,opt,name=message_count,json=messageCount,proto3" json:"message_count,omitempty"`
	// The interval (ms) between two server messages. The server implementation
	// may enforce some minimum interval (e.g. 100ms) to avoid message overflow.
	MessageInterval      int32    `protobuf:"varint,3,opt,name=message_interval,json=messageInterval,proto3" json:"message_interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerStreamingEchoRequest) Reset()         { *m = ServerStreamingEchoRequest{} }
func (m *ServerStreamingEchoRequest) String() string { return proto.CompactTextString(m) }
func (*ServerStreamingEchoRequest) ProtoMessage()    {}
func (*ServerStreamingEchoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_echo_3348184e55b97ceb, []int{3}
}
func (m *ServerStreamingEchoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerStreamingEchoRequest.Unmarshal(m, b)
}
func (m *ServerStreamingEchoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerStreamingEchoRequest.Marshal(b, m, deterministic)
}
func (dst *ServerStreamingEchoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerStreamingEchoRequest.Merge(dst, src)
}
func (m *ServerStreamingEchoRequest) XXX_Size() int {
	return xxx_messageInfo_ServerStreamingEchoRequest.Size(m)
}
func (m *ServerStreamingEchoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerStreamingEchoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ServerStreamingEchoRequest proto.InternalMessageInfo

func (m *ServerStreamingEchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *ServerStreamingEchoRequest) GetMessageCount() int32 {
	if m != nil {
		return m.MessageCount
	}
	return 0
}

func (m *ServerStreamingEchoRequest) GetMessageInterval() int32 {
	if m != nil {
		return m.MessageInterval
	}
	return 0
}

// Response type for server streaming response.
type ServerStreamingEchoResponse struct {
	// Response message.
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ServerStreamingEchoResponse) Reset()         { *m = ServerStreamingEchoResponse{} }
func (m *ServerStreamingEchoResponse) String() string { return proto.CompactTextString(m) }
func (*ServerStreamingEchoResponse) ProtoMessage()    {}
func (*ServerStreamingEchoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_echo_3348184e55b97ceb, []int{4}
}
func (m *ServerStreamingEchoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ServerStreamingEchoResponse.Unmarshal(m, b)
}
func (m *ServerStreamingEchoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ServerStreamingEchoResponse.Marshal(b, m, deterministic)
}
func (dst *ServerStreamingEchoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServerStreamingEchoResponse.Merge(dst, src)
}
func (m *ServerStreamingEchoResponse) XXX_Size() int {
	return xxx_messageInfo_ServerStreamingEchoResponse.Size(m)
}
func (m *ServerStreamingEchoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ServerStreamingEchoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ServerStreamingEchoResponse proto.InternalMessageInfo

func (m *ServerStreamingEchoResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Request type for client side streaming echo.
type ClientStreamingEchoRequest struct {
	// A special value "" indicates that there's no further messages.
	Message              string   `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamingEchoRequest) Reset()         { *m = ClientStreamingEchoRequest{} }
func (m *ClientStreamingEchoRequest) String() string { return proto.CompactTextString(m) }
func (*ClientStreamingEchoRequest) ProtoMessage()    {}
func (*ClientStreamingEchoRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_echo_3348184e55b97ceb, []int{5}
}
func (m *ClientStreamingEchoRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientStreamingEchoRequest.Unmarshal(m, b)
}
func (m *ClientStreamingEchoRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientStreamingEchoRequest.Marshal(b, m, deterministic)
}
func (dst *ClientStreamingEchoRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamingEchoRequest.Merge(dst, src)
}
func (m *ClientStreamingEchoRequest) XXX_Size() int {
	return xxx_messageInfo_ClientStreamingEchoRequest.Size(m)
}
func (m *ClientStreamingEchoRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamingEchoRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamingEchoRequest proto.InternalMessageInfo

func (m *ClientStreamingEchoRequest) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

// Response type for client side streaming echo.
type ClientStreamingEchoResponse struct {
	// Total number of client messages that have been received.
	MessageCount         int32    `protobuf:"varint,1,opt,name=message_count,json=messageCount,proto3" json:"message_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ClientStreamingEchoResponse) Reset()         { *m = ClientStreamingEchoResponse{} }
func (m *ClientStreamingEchoResponse) String() string { return proto.CompactTextString(m) }
func (*ClientStreamingEchoResponse) ProtoMessage()    {}
func (*ClientStreamingEchoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_echo_3348184e55b97ceb, []int{6}
}
func (m *ClientStreamingEchoResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ClientStreamingEchoResponse.Unmarshal(m, b)
}
func (m *ClientStreamingEchoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ClientStreamingEchoResponse.Marshal(b, m, deterministic)
}
func (dst *ClientStreamingEchoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientStreamingEchoResponse.Merge(dst, src)
}
func (m *ClientStreamingEchoResponse) XXX_Size() int {
	return xxx_messageInfo_ClientStreamingEchoResponse.Size(m)
}
func (m *ClientStreamingEchoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientStreamingEchoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ClientStreamingEchoResponse proto.InternalMessageInfo

func (m *ClientStreamingEchoResponse) GetMessageCount() int32 {
	if m != nil {
		return m.MessageCount
	}
	return 0
}

func init() {
	proto.RegisterType((*Empty)(nil), "grpc.gateway.testing.Empty")
	proto.RegisterType((*EchoRequest)(nil), "grpc.gateway.testing.EchoRequest")
	proto.RegisterType((*EchoResponse)(nil), "grpc.gateway.testing.EchoResponse")
	proto.RegisterType((*ServerStreamingEchoRequest)(nil), "grpc.gateway.testing.ServerStreamingEchoRequest")
	proto.RegisterType((*ServerStreamingEchoResponse)(nil), "grpc.gateway.testing.ServerStreamingEchoResponse")
	proto.RegisterType((*ClientStreamingEchoRequest)(nil), "grpc.gateway.testing.ClientStreamingEchoRequest")
	proto.RegisterType((*ClientStreamingEchoResponse)(nil), "grpc.gateway.testing.ClientStreamingEchoResponse")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EchoServiceClient is the client API for EchoService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EchoServiceClient interface {
	// One request followed by one response
	// The server returns the client message as-is.
	Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// Sends back abort status.
	EchoAbort(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error)
	// One empty request, ZERO processing, followed by one empty response
	// (minimum effort to do message serialization).
	NoOp(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
	// One request followed by a sequence of responses (streamed download).
	// The server will return the same client message repeatedly.
	ServerStreamingEcho(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoClient, error)
	// One request followed by a sequence of responses (streamed download).
	// The server abort directly.
	ServerStreamingEchoAbort(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoAbortClient, error)
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the total number of messages as the result.
	ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_ClientStreamingEchoClient, error)
	// A sequence of requests with each message echoed by the server immediately.
	// The server returns the same client messages in order.
	// E.g. this is how the speech API works.
	FullDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_FullDuplexEchoClient, error)
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client messages and then returns the same
	// client messages one by one after the client half-closes the stream.
	// This is how an image recognition API may work.
	HalfDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_HalfDuplexEchoClient, error)
}

type echoServiceClient struct {
	cc *grpc.ClientConn
}

func NewEchoServiceClient(cc *grpc.ClientConn) EchoServiceClient {
	return &echoServiceClient{cc}
}

func (c *echoServiceClient) Echo(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := c.cc.Invoke(ctx, "/grpc.gateway.testing.EchoService/Echo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) EchoAbort(ctx context.Context, in *EchoRequest, opts ...grpc.CallOption) (*EchoResponse, error) {
	out := new(EchoResponse)
	err := c.cc.Invoke(ctx, "/grpc.gateway.testing.EchoService/EchoAbort", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) NoOp(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/grpc.gateway.testing.EchoService/NoOp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *echoServiceClient) ServerStreamingEcho(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EchoService_serviceDesc.Streams[0], "/grpc.gateway.testing.EchoService/ServerStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceServerStreamingEchoClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EchoService_ServerStreamingEchoClient interface {
	Recv() (*ServerStreamingEchoResponse, error)
	grpc.ClientStream
}

type echoServiceServerStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceServerStreamingEchoClient) Recv() (*ServerStreamingEchoResponse, error) {
	m := new(ServerStreamingEchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) ServerStreamingEchoAbort(ctx context.Context, in *ServerStreamingEchoRequest, opts ...grpc.CallOption) (EchoService_ServerStreamingEchoAbortClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EchoService_serviceDesc.Streams[1], "/grpc.gateway.testing.EchoService/ServerStreamingEchoAbort", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceServerStreamingEchoAbortClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EchoService_ServerStreamingEchoAbortClient interface {
	Recv() (*ServerStreamingEchoResponse, error)
	grpc.ClientStream
}

type echoServiceServerStreamingEchoAbortClient struct {
	grpc.ClientStream
}

func (x *echoServiceServerStreamingEchoAbortClient) Recv() (*ServerStreamingEchoResponse, error) {
	m := new(ServerStreamingEchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) ClientStreamingEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_ClientStreamingEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EchoService_serviceDesc.Streams[2], "/grpc.gateway.testing.EchoService/ClientStreamingEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceClientStreamingEchoClient{stream}
	return x, nil
}

type EchoService_ClientStreamingEchoClient interface {
	Send(*ClientStreamingEchoRequest) error
	CloseAndRecv() (*ClientStreamingEchoResponse, error)
	grpc.ClientStream
}

type echoServiceClientStreamingEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceClientStreamingEchoClient) Send(m *ClientStreamingEchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceClientStreamingEchoClient) CloseAndRecv() (*ClientStreamingEchoResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(ClientStreamingEchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) FullDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_FullDuplexEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EchoService_serviceDesc.Streams[3], "/grpc.gateway.testing.EchoService/FullDuplexEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceFullDuplexEchoClient{stream}
	return x, nil
}

type EchoService_FullDuplexEchoClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type echoServiceFullDuplexEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceFullDuplexEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceFullDuplexEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *echoServiceClient) HalfDuplexEcho(ctx context.Context, opts ...grpc.CallOption) (EchoService_HalfDuplexEchoClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EchoService_serviceDesc.Streams[4], "/grpc.gateway.testing.EchoService/HalfDuplexEcho", opts...)
	if err != nil {
		return nil, err
	}
	x := &echoServiceHalfDuplexEchoClient{stream}
	return x, nil
}

type EchoService_HalfDuplexEchoClient interface {
	Send(*EchoRequest) error
	Recv() (*EchoResponse, error)
	grpc.ClientStream
}

type echoServiceHalfDuplexEchoClient struct {
	grpc.ClientStream
}

func (x *echoServiceHalfDuplexEchoClient) Send(m *EchoRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *echoServiceHalfDuplexEchoClient) Recv() (*EchoResponse, error) {
	m := new(EchoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EchoServiceServer is the server API for EchoService service.
type EchoServiceServer interface {
	// One request followed by one response
	// The server returns the client message as-is.
	Echo(context.Context, *EchoRequest) (*EchoResponse, error)
	// Sends back abort status.
	EchoAbort(context.Context, *EchoRequest) (*EchoResponse, error)
	// One empty request, ZERO processing, followed by one empty response
	// (minimum effort to do message serialization).
	NoOp(context.Context, *Empty) (*Empty, error)
	// One request followed by a sequence of responses (streamed download).
	// The server will return the same client message repeatedly.
	ServerStreamingEcho(*ServerStreamingEchoRequest, EchoService_ServerStreamingEchoServer) error
	// One request followed by a sequence of responses (streamed download).
	// The server abort directly.
	ServerStreamingEchoAbort(*ServerStreamingEchoRequest, EchoService_ServerStreamingEchoAbortServer) error
	// A sequence of requests followed by one response (streamed upload).
	// The server returns the total number of messages as the result.
	ClientStreamingEcho(EchoService_ClientStreamingEchoServer) error
	// A sequence of requests with each message echoed by the server immediately.
	// The server returns the same client messages in order.
	// E.g. this is how the speech API works.
	FullDuplexEcho(EchoService_FullDuplexEchoServer) error
	// A sequence of requests followed by a sequence of responses.
	// The server buffers all the client messages and then returns the same
	// client messages one by one after the client half-closes the stream.
	// This is how an image recognition API may work.
	HalfDuplexEcho(EchoService_HalfDuplexEchoServer) error
}

func RegisterEchoServiceServer(s interface {
	RegisterService(*grpc.ServiceDesc, interface{})
}, srv EchoServiceServer) {
	s.RegisterService(&_EchoService_serviceDesc, srv)
}

func _EchoService_Echo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).Echo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.gateway.testing.EchoService/Echo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).Echo(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_EchoAbort_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EchoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).EchoAbort(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.gateway.testing.EchoService/EchoAbort",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).EchoAbort(ctx, req.(*EchoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_NoOp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EchoServiceServer).NoOp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/grpc.gateway.testing.EchoService/NoOp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EchoServiceServer).NoOp(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _EchoService_ServerStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ServerStreamingEchoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EchoServiceServer).ServerStreamingEcho(m, &echoServiceServerStreamingEchoServer{stream})
}

type EchoService_ServerStreamingEchoServer interface {
	Send(*ServerStreamingEchoResponse) error
	grpc.ServerStream
}

type echoServiceServerStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceServerStreamingEchoServer) Send(m *ServerStreamingEchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EchoService_ServerStreamingEchoAbort_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ServerStreamingEchoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EchoServiceServer).ServerStreamingEchoAbort(m, &echoServiceServerStreamingEchoAbortServer{stream})
}

type EchoService_ServerStreamingEchoAbortServer interface {
	Send(*ServerStreamingEchoResponse) error
	grpc.ServerStream
}

type echoServiceServerStreamingEchoAbortServer struct {
	grpc.ServerStream
}

func (x *echoServiceServerStreamingEchoAbortServer) Send(m *ServerStreamingEchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _EchoService_ClientStreamingEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).ClientStreamingEcho(&echoServiceClientStreamingEchoServer{stream})
}

type EchoService_ClientStreamingEchoServer interface {
	SendAndClose(*ClientStreamingEchoResponse) error
	Recv() (*ClientStreamingEchoRequest, error)
	grpc.ServerStream
}

type echoServiceClientStreamingEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceClientStreamingEchoServer) SendAndClose(m *ClientStreamingEchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceClientStreamingEchoServer) Recv() (*ClientStreamingEchoRequest, error) {
	m := new(ClientStreamingEchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EchoService_FullDuplexEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).FullDuplexEcho(&echoServiceFullDuplexEchoServer{stream})
}

type EchoService_FullDuplexEchoServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type echoServiceFullDuplexEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceFullDuplexEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceFullDuplexEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _EchoService_HalfDuplexEcho_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EchoServiceServer).HalfDuplexEcho(&echoServiceHalfDuplexEchoServer{stream})
}

type EchoService_HalfDuplexEchoServer interface {
	Send(*EchoResponse) error
	Recv() (*EchoRequest, error)
	grpc.ServerStream
}

type echoServiceHalfDuplexEchoServer struct {
	grpc.ServerStream
}

func (x *echoServiceHalfDuplexEchoServer) Send(m *EchoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *echoServiceHalfDuplexEchoServer) Recv() (*EchoRequest, error) {
	m := new(EchoRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EchoService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "grpc.gateway.testing.EchoService",
	HandlerType: (*EchoServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Echo",
			Handler:    _EchoService_Echo_Handler,
		},
		{
			MethodName: "EchoAbort",
			Handler:    _EchoService_EchoAbort_Handler,
		},
		{
			MethodName: "NoOp",
			Handler:    _EchoService_NoOp_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ServerStreamingEcho",
			Handler:       _EchoService_ServerStreamingEcho_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ServerStreamingEchoAbort",
			Handler:       _EchoService_ServerStreamingEchoAbort_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ClientStreamingEcho",
			Handler:       _EchoService_ClientStreamingEcho_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FullDuplexEcho",
			Handler:       _EchoService_FullDuplexEcho_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "HalfDuplexEcho",
			Handler:       _EchoService_HalfDuplexEcho_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "echo/echo.proto",
}

func init() { proto.RegisterFile("echo/echo.proto", fileDescriptor_echo_3348184e55b97ceb) }

var fileDescriptor_echo_3348184e55b97ceb = []byte{
	// 375 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x54, 0x4f, 0x4b, 0xfb, 0x40,
	0x10, 0xed, 0xfe, 0x7e, 0xfd, 0x43, 0xc7, 0x6a, 0x65, 0xf5, 0x10, 0xd2, 0x4b, 0x5d, 0x0f, 0xc6,
	0x4b, 0x8c, 0x0a, 0x7a, 0x55, 0x6b, 0x45, 0x0f, 0x55, 0x68, 0xbd, 0x79, 0x90, 0x34, 0x8c, 0x69,
	0x20, 0xcd, 0xc6, 0x64, 0x53, 0x2d, 0x78, 0x13, 0xfc, 0x3c, 0x7e, 0x44, 0xd9, 0x26, 0x05, 0xa1,
	0x9b, 0xda, 0x42, 0xf5, 0x12, 0x32, 0x93, 0x37, 0x33, 0xef, 0xcd, 0x3c, 0x02, 0x75, 0x74, 0x06,
	0xfc, 0x40, 0x3e, 0xcc, 0x30, 0xe2, 0x82, 0xd3, 0x6d, 0x37, 0x0a, 0x1d, 0xd3, 0xb5, 0x05, 0xbe,
	0xd8, 0x63, 0x53, 0x60, 0x2c, 0xbc, 0xc0, 0x65, 0x15, 0x28, 0xb5, 0x87, 0xa1, 0x18, 0xb3, 0x3d,
	0x58, 0x6b, 0x3b, 0x03, 0xde, 0xc5, 0xe7, 0x04, 0x63, 0x41, 0x35, 0xa8, 0x0c, 0x31, 0x8e, 0x6d,
	0x17, 0x35, 0xd2, 0x24, 0x46, 0xb5, 0x3b, 0x0d, 0x59, 0x07, 0x6a, 0x29, 0x30, 0x0e, 0x79, 0x10,
	0x63, 0x3e, 0x92, 0xee, 0xc2, 0x7a, 0xf6, 0xfa, 0xe8, 0xf0, 0x24, 0x10, 0xda, 0xbf, 0x26, 0x31,
	0x4a, 0xdd, 0x5a, 0x96, 0x6c, 0xc9, 0x1c, 0xfb, 0x20, 0xa0, 0xf7, 0x30, 0x1a, 0x61, 0xd4, 0x13,
	0x11, 0xda, 0x43, 0x2f, 0x70, 0x17, 0xe2, 0xb1, 0x50, 0x77, 0xba, 0x0f, 0x9b, 0x53, 0x90, 0x17,
	0x08, 0x8c, 0x46, 0xb6, 0xaf, 0xfd, 0x9f, 0xe0, 0xea, 0x59, 0xfe, 0x26, 0x4b, 0xb3, 0x53, 0x68,
	0x28, 0x79, 0xfc, 0x24, 0x93, 0x9d, 0x80, 0xde, 0xf2, 0x3d, 0x0c, 0xc4, 0x72, 0x02, 0xd8, 0x05,
	0x34, 0x94, 0x75, 0xd9, 0xc0, 0x19, 0x7d, 0x64, 0x56, 0xdf, 0xd1, 0x67, 0x39, 0x3d, 0x9b, 0x64,
	0xee, 0x39, 0x48, 0x3b, 0x50, 0x94, 0x21, 0xdd, 0x31, 0x55, 0xd7, 0x36, 0xbf, 0x11, 0xd3, 0xd9,
	0x3c, 0x48, 0xc6, 0xe1, 0x1e, 0xaa, 0x32, 0x3e, 0xef, 0xf3, 0x48, 0xac, 0xa8, 0x27, 0x2b, 0xd0,
	0x33, 0x28, 0xde, 0xf2, 0xbb, 0x90, 0x36, 0x72, 0xd0, 0xd2, 0x8f, 0xfa, 0xbc, 0x8f, 0xf4, 0x0d,
	0xb6, 0x14, 0xb7, 0xa2, 0x96, 0xba, 0x26, 0xdf, 0x5e, 0xfa, 0xe1, 0x12, 0x15, 0x29, 0x7f, 0x8b,
	0xd0, 0x77, 0x02, 0x9a, 0x02, 0x91, 0x6e, 0xe9, 0x2f, 0x38, 0xb0, 0x82, 0x45, 0xe4, 0x0e, 0x14,
	0xf6, 0xc9, 0x9b, 0x9f, 0xef, 0xd0, 0xbc, 0xf9, 0x73, 0xbc, 0x69, 0x10, 0xfa, 0x00, 0x1b, 0x57,
	0x89, 0xef, 0x5f, 0x26, 0xa1, 0x8f, 0xaf, 0x2b, 0xb4, 0x9c, 0x41, 0xac, 0x49, 0xf3, 0x6b, 0xdb,
	0x7f, 0xfa, 0x95, 0xe6, 0xfd, 0xf2, 0xe4, 0x77, 0x78, 0xfc, 0x15, 0x00, 0x00, 0xff, 0xff, 0x5c,
	0x9f, 0xac, 0x5b, 0x21, 0x05, 0x00, 0x00,
}
